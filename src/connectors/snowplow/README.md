# Snowplow Events

This doc is not exhaustive, but lays out how we work with Snowplow on this repo.

_This doc is a work in progress. Some things are definitely missing... for now..._

# Overview

We use Snowplow to capture user analytics in our front-end code. Snowplow is our 3rd party tracking system that offers some automatic tracking and a full suite of customizable events.

For full documentation of Snowplow please refer to the [official docs](https://docs.snowplow.io/docs)

## Folder Structure

- `actions`: Where every action is defined
- `entities`: Builds an entity to attach to each event
- `events`: Builds the event to send

## Terminology

For the sake of readability, there’s a few terms used in this document we should be aligned on:
- action: A defined interaction that includes an event and any attached entities.
- event: An event is the type of interaction we are capturing. Every request made to Snowplow is made from an event with attached entities.
- entity: Entities are all of the additional information about the interaction we’d like to capture
- schema: Defines the structure of the data that you collect, set with a version number

## Anatomy of a Request

### Schema

The schema is essentially the version number of the event/entity requirements. That way the data team can update the structure/requirements without it having downstream effects.

When initializing events we define the schema used with our `getSchemaUri` function. This defaults to a `1-0-0` version number.

An example of how/why we may update the schema we’re using: The initial version of the ui schema had a limited number of components; `button`, `dialog`, `menu`, `card`, `list`, and `screen`. This schema was updated to add additional components, including a `link` component. In order to be able to use this `link` component, we need to point to the updated schema; `1-0-2`.

### Events

An event is the type of interaction we are capturing. Every request made to Snowplow is made from an event with attached entities. Events are included in our actions with the `eventType` field.

- `Pageview`: this event is fired every page view. Happens automatically in web-client whenever it detects a path change.

- `Page Ping`: tracks the length of time a user views a page. Happens automatically every 10 seconds.

- `link_click`: tracks any link clicked on a page. Happens automatically. Does not apply to links rendered after initial page load.

- `*_form`: tracks interactions on a form field in the page. Consists of focus_form, change_form, submit_form. Happens automatically. Does not apply to form fields rendered after initial page load.

- `impression`: when an element comes into view.

- `engagement`: when a user clicks on an element.

- `content_open`: when a user clicks an item, usually in a card element, sometimes a link within an article.

- `variant_enroll`: when the application enrolls a user in a test. Happens automatically. _(NOTE: The analytics team has requested that we update this event to only fire when a user would typically see the experiement, not on page load)_

### Entities

Attached to each snowplow event are an array of Entities. Some are included automatically with every request sent (`user` and `api_user`). Entities are included in our ections with the `entityTypes` field.

- `api_user`: Identifies a user with a hashed id generated by the backend. Includes the version number of the application. Included automatically on every event.

- `content`: Represents a unique piece of content within Pocket. Always includes a `url`, often includes an `item_id`.

- `corpus_recommendation`: Describes a content recommendation. Should be included with any impression or engagement events with recommendations. Always includes a `corpus_recommendation_id`.

- `feature_flag`: Included with the variant_enroll event. Contains the name of the experiment and the variant the user is enrolled to. There must always be a control value as a variant.

- `newsletter_subscriber`: Sent when a user signs up for the Pocket Hits newsletter.

- `recommendation`: Represents a recommendation item from the RecsAPI endpoint. Always includes a `recommendation_id` and a position/index.

- `report`: Used when a user reports an article on our Explore/Discover pages as being inappropriate.

- `slate_lineup`: Identifies a group of slates from the RecsAPI endpoint.

- `slate`: Identifies a group of recommendations from the RecsAPI endpoint.

- `ui`: Describes an element in the user interface. Should be included with any impression, engagement, or custom engagement events.

- `user`: Describes a user based on available identifiers. At a minimum contains a session id, and a user id (if the user is logged in)

# How to Read Defined Events

All analytics events are defined in the `actions` folder. Each file should correlate to a section in the application.

For example: imagine you want to know which event and entities are tracked when a user saves an item on Home. Let's take a look at the event below (stored in the [Home actions](actions/home.js) file) and break down all the parts:

```
  'home.corpus.save': {
    eventType: 'engagement',
    entityTypes: ['content', 'ui', 'corpusRecommendation'],
    eventData: {
      engagementType: 'save',
      uiType: 'button'
    },
    expects: ['corpusRecommendationId', 'url'],
    description: 'Click “Save” on a card in baseline home'
  }
```

The first line in the event is the descriptive key which is also used as the `identifier` for `ui` entities. These identifiers have an informal naming scheme. The first portion is specific to the area or feature of the application. The second optional portion adds some specificity and helps clarify the section where the action takes place. The last portion describes the action taking place, and often mirrors or augments the event type.

So to round it all out, the identifiers mostly adhere to the below format:
```
feature.section[optional].action
```

When this event is sent off to Snowplow, it defines the `eventType` as `engagement` and the `entityTypes` included with this event are `content`, `ui`, and `corpus_recommendation`. These are the event and entities respectively.

Some data included with events and entities are hardcoded and will never change. This data is defined in the `eventData` object. The save event outlined in the paragraph above has the`engagementType`and `uiType` passed in.

Variable data is defined in the `expects` array. We use this array to make sure that all the required info is passed when sending this event. If an event is fired without all the required data points defined in the `expects` array, a `console.warning` is fired in dev environments, or a Sentry error is sent when on production.

The `description` key is optional and is only used by developers to help add context when trying to read through defined events.

# Developing With Snowplow

## Initialization

Snowplow is initialized at the top level of the application. This happens once per application load, and will only occur once the logged in/out status of the user has been determined, whether OneTrust has finished loading, and we have a `sess_guid`.

Initialization is where we enable automatic link tracking, form tracking, the heartbeat (`link_click`, `*_form`, and `Page Ping`, respectively), and define the entities to include on every request (`api_user` and `user`).

This is also when any stored user data is cleared if a user has opted out of analytics cookies.

### Configuration

There are two different configurations when initializing Snowplow depending on whether the user has opted out of analytics cookies (via the OneTrust integration).

The difference between the two determines how events are sent, and whether to use local storage for user data.

By default all events are sent with the `eventMethod` set to `beacon`. This means that even if a user leaves the application, events can still finish being sent in the background. If an event doesn't complete the send, it will occur when the user returns to the application. User info and unsent events are stored in local storage and cookies (with `stateStorageStrategy` set to `cookieAndLocalStorage`)

When a user has opted out of using analytics cookies, the `eventMethod` is set to `post`. This guarantees that the event is fired before the user is able to navigate away from the page and won't happen in the background. Instead of full user info being sent `anonymousTracking` is turned on with `withServerAnonymisation` set to `true`. `stateStorageStrategy`is set to`none`.

Here are the two different configurations:
```
// Allow cookies
{
  appId: <SNOWPLOW_APP_ID>,
  platform: 'web',
  eventMethod: 'beacon',
  respectDoNotTrack: false,
  stateStorageStrategy: 'cookieAndLocalStorage',
  contexts: { webPage: true, performanceTiming: true },
  postPath: <SNOWPLOW_POST_PATH>
}

// Do not allow cookies
{
  appId: <SNOWPLOW_APP>,
  platform: 'web',
  eventMethod: 'post',
  respectDoNotTrack: false,
  stateStorageStrategy: 'none',
  contexts: { webPage: true, performanceTiming: true },
  anonymousTracking: { withServerAnonymisation: true },
  postPath: <SNOWPLOW_POST_PATH>
}
```

If a user updates their OneTrust cookie settings in the middle of a session we clear all user data and then refresh the page. The page refresh is required to update the `eventMethod` as this can’t be changed once Snowplow has been initialized (unlike the `stateStorageStrategy` and `anonymousTracking` settings).

### Dev vs Production

There’s a couple key differences between how we initialize Snowplow in our dev environments vs production. When we’re in a local environment, we use a different `appId`, send the events to a different endpoint, and load a different Snowplow javascript file. If you take a look at our [constants](../../common/constants.js) file, you’ll see we have a few different environment specific variables. The `process.env.SHOW_DEV === 'included'` that we check for is what determines dev vs production. That variable is set in the run dev script in the `package.json` file, and happens automatically depending on how you start the application from your terminal (`npm run dev` vs `npm run start`)

_NOTE: Ad Blockers will prevent Snowplow from sending events in our development environment. It’s best to disable these blockers on getpocket.com_

We are also able to run tests using Snowplow micro. _*TODO: More info to come on this*_

### Do Not Track

We currently initialize Snowplow with the `respectDoNotTrack` parameter set to false. Most modern browsers have a setting that allows users to ask web sites to not track them. While this may feel counter to Mozilla’s mission, the Data Team found that we were unable to capture any Snowplow events when we respected this parameter, resulting in TONS of lost data.

## How Requests Are Sent

...

## How to Add New Actions

Most new requests tend to be one of three kinds: `engagement`, `impression`, and `content_open`.

Let’s look at our Reader View for an example of how requests are set up, and use that as a template for how to set up new ones! We’ll go over how to set up a hypothetical engagement event for a “Copy Link” button.

### Defining an Action

The first thing to decide is what to name the action. If in doubt on where to start, it’s best to check how other actions in this area of the application have been named. For this example you can look at the [Reader actions](actions/reader.js). The area of the application is Reader, so that will be the first portion in the identifier. There isn’t a need to add further specificity given the straight forward nature of the Reader, so we can use `copy-link` for the next portion. We end up with `reader.copy-link` for the action name.

Next we need to decide the specific event and any entities to include with this action. For this example we’ll want to set the `eventType` as `engagement`. For entities, we first have to consider whether the action is related to an item. Given that this interaction exists on a page specifically related to an item’s content, it’s a clue that we’ll need to include the `content` entity with our event. And since the user will be clicking a button to trigger this event, the `ui` entity is also needed.

Now that we know the `eventType` and `entityTypes` for this action, we need to determine which info to include with this action. It’s best to check the requirements for each event and entity. To do that you can take a look at the [engagement event](/events/engagement.js), and then at [ui](/entities/ui.js) and [content](entities/content.js) for the entities.

Let's take a look at the requirements for the `engagement` event. According to the schema we need to define an `engagementType`. For this value there’s currently three options: `general`, `save`, and `report`. This isn’t a save action, and we’re not reporting anything, so we’ll go with `general`. Luckily this is the default value, so we don't need to include this value for this specific action.

Next we’ll take a look at the `ui` entity. Looking at the required values we need to define `uiType`, `hierarchy`, and `identifier`. Luckily we don’t need to specify anything for `hierarchy` or `identifier`. The `hierarchy` value defaults to `0` on our platform, and is mostly relevant to the mobile applications only. We’ve already handled the `identifier` value since it’s also the name of the action. That leaves us the `uiType` value. Out of the available options `button` is the most representative of the element the user is interacting with.

As mentioned near the top of this document, we can hard-code some data to include with this action as the `eventData` object since it will never change. For the event for this demo, we’ll add `uiType: button`.

The data required by the `content` entity is specific to the item being viewed. This entity will _always_ need a `url`. Only saved items will have an `id`. Since this action is on Reader, which is only available if an item has been saved, we’ll include it in this action.
Since this data changes, we can’t hard-code any of this info for the action, so let’s move on to what this action `expects`.

The `expects` value is the additional required data that we need to manually pass to this action. As we covered in the paragraph above, the `content` entity _has_ to have a `url`, and since this item is saved we’ll also include the `id`. When this event eventually gets sent to Snowplow, a validator will be run against this action to ensure all data in the `expects` field is present. If any data is missing a `console.warning` is fired in dev environments, or a Sentry error is sent when on production.

Finally we’ll add the `description` field to help add additional context for anyone coming after you to see what this action does.

After going through the steps above, the resulting action should look something like this:
```
'reader.copy-link': {
  eventType: 'engagement',
  entityTypes: ['content', 'ui'],
  eventData: {
    uiType: 'button'
  },
  expects: ['id', 'url'],
  description: 'Fired when a user clicks the `Copy Link` button on Reader'
}
```

Excellent!

Now we need to fire this action from the Reader.

### Sending an Action

Imagine there’s a new button, and on that button’s `onClick` event we’ll set up a function called `onCopyClick`.
```
const onCopyClick = () => {}
```

When this function is called, we’ll then call the analytics function wrapped in a [dispatch](https://react-redux.js.org/api/hooks#usedispatch) react hook. (Make sure to import the `sendSnowplowEvent` function from the analytics file)

The `sendSnowplowEvent` function takes two arguments:
1. The action name/identifier
2. The required data in the shape of a javascript object

When reading how the action is defined we can see that it `expects` the `url` and `id` of the item, so we’ll make sure to include that in the second argument.

In the end it may look like the following:
```
import { sendSnowplowEvent } from 'connectors/snowplow/snowplow.state'

export const CopyLinkButton = ({ savedItem }) => {
  const { url, id } = savedItem
  const analyticsData = { url, id }

  const onCopyClick = () => dispatch(sendSnowplowEvent('reader.copy-link', analyticsData))

  render (
    <button onClick={onCopyClick}>Copy Link</button>
  )
}
```
_(NOTE: The above code has been written with education in mind and may not reflect how it’ll look in the actual implementation)_

It’s always best practice to define the action first before sending them from components. If you send an action with an `identifier` that isn't in one of these `actions` files, you'll get a nasty error in the browser console 💀

And that’s it! You should now be sending the action to Snowplow!

## How to Add New Entities or Events

Occasionally we'll need to add new `events` or `entities`. This happens when we need to capture a new type of interaction or there's a new data-type we need to track.

### Adding a New Event/Entity

For this walkthrough let's imagine that we need to include a new `ad` entity in the application. First we'd add a new file named `ad.js` in the [events](/events/) folder.

Next, we'd visit the [defined schema](https://console.snowplowanalytics.com/cf0fba6b-23b3-49a0-9d79-7ce18b8f9618/data-structures/dcfe0061541a1b0bc50def4b4ec18fbaebb4ec095724f6bd5a75881749a84acf) for this entity. Take careful note of all the `properties` for this schema, and make note of which ones are required vs optional. As of the time of writing this document all parameters for this entity are required.

At the top of `ad.js` we first import the `getSchemaUri` function:
```
import { getSchemaUri } from 'connectors/snowplow/snowplow.utilities'
```

This function takes two arguments:
1. The event/entity name as set by the `self.name` field in the schema definition
2. The version number as set by the `self.version` field in the schema definition

The second argument defaults to `1-0-0`, so there's no need to pass in this argument unless we need to point to a specific or newer version of the schema

We have a convention of adding a link to the schema information after the imports, so add this to the file next.
```
/**
 * Schema information:
 * https://console.snowplowanalytics.com/cf0fba6b-23b3-49a0-9d79-7ce18b8f9618/data-structures/dcfe0061541a1b0bc50def4b4ec18fbaebb4ec095724f6bd5a75881749a84acf
 */
```

Next task is to define the schema url. This is an important `const` so we use an all caps, snake case format:
```
const AD_SCHEMA_URL = getSchemaUri('ad')
```

Now we include a comment block that lists the `description` of the schema, and each property, as well as if the property is required or optional. _Note: these properties are listed in camel case format as they match how the data is passed through the application, and we have a convention of using camel case for these types of variables._ At the end of this comment block we note what the shape this data will be returned as:
```
/**
 * An ad within Pocket. Should be included with any content entity if the content is also an ad.
 *
 * @param adId {int} - The backend identifier for an ad. @required
 * @param zoneId {int} - The identifier for an ad’s zone. @required
 * @param siteId {int} - The identifier for an ad’s site. @required
 * @returns {{schema: *, data: {ad_id: int, zone_id: int, site_id: int}}}
 */
```

Finally we're on to the function that builds our entity. The function you create should accept a [single destructured argument](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#unpacking_properties_from_objects_passed_as_a_function_parameter), with each property included. This is also the chance to assign any default values to the properties.

This function should return a javascript object with two properties: `schema` and `data`.

The `data` property is where each camel case value is assigned back to the snake case version:
```
export const createAdEntity = ({ adId, zoneId, siteId }) => ({
  schema: AD_SCHEMA_URL,
  data: {
    ad_id: adId,
    zone_id: zoneId,
    site_id: siteId
  }
})
```

If you are creating an event or entity with optional values, the object in the data property should be wrapped with our `getObjectWithValidKeysOnly` utility. This ensures that no empty values are passed into Snowplow which will result in an error. You can take a look at our [content entity](/entities/content.js) for an example.

Finally at the end of the file we need to export the `createAdEntity` function.

If you've been following along, your resulting code should look something like this:
```
import { getSchemaUri } from 'connectors/snowplow/snowplow.utilities'

/**
 * Schema information:
 * https://console.snowplowanalytics.com/cf0fba6b-23b3-49a0-9d79-7ce18b8f9618/data-structures/dcfe0061541a1b0bc50def4b4ec18fbaebb4ec095724f6bd5a75881749a84acf
 */
const AD_SCHEMA_URL = getSchemaUri('ad')

/**
 * An ad within Pocket. Should be included with any content entity if the content is also an ad.
 *
 * @param adId {int} - The backend identifier for an ad. @required
 * @param zoneId {int} - The identifier for an ad’s zone. @required
 * @param siteId {int} - The identifier for an ad’s site. @required
 * @returns {{schema: *, data: {ad_id: int, zone_id: int, site_id: int}}}
 */
export const createAdEntity = ({ adId, zoneId, siteId }) => ({
  schema: AD_SCHEMA_URL,
  data: {
    ad_id: adId,
    zone_id: zoneId,
    site_id: siteId
  }
})

export default createAdEntity
```

Congrats! 🎉

You've defined a brand new entity! Next we need to ensure that we can use this entity with our actions.

For the time being, we import all entities/events into an `index.js` file within the `entities` or `events` folder, and then export them out again. This may change in the future. So for the sake of these instructions check the [index](entities/index.js) file and follow the existing pattern to import and re-export the `createAdEntity` function.

In [snowplow.state.js](snowplow.state.js) where we build and send our snowplow events we have defined javascript objects where each key points to the function that creates our events/entities. These constants are called `eventBuilders` and `entityBuilders`.

Since we're adding a new entity we'll want to update the `entityBuilders` constant with the `createAdEntity` function.

So at the top of `snowplow.state.js` you'll import the `createAdEntity` function:
```
import { createAdEntity } from 'connectors/snowplow/entities'
```

Then you'll find the `entityBuilders` constant and update it to include our new ad entity creator:
```
const entityBuilders = {
  ui: createUiEntity,
  content: createContentEntity,
  newsletterSubscriber: createNewsletterSubscriberEntity,
  recommendation: createRecommendationEntity,
  corpusRecommendation: createCorpusRecommendationEntity,
  report: createReportEntity,
  slate: createSlateEntity,
  slateLineup: createSlateLineupEntity,
  ad: createAdEntity
}
```

Now that that's added, you'll want to update the `expectationTypes` function to include the new properties that the `ad` entity expects:
```
const expectationTypes = {
  ...
  adId: 'string',
  zoneId: 'string',
  siteId: 'string
}
```

When the event and entities are being built for all actions, the values in the `expects` field are verified against the `expectationTypes`. If there's a mismatch in type or a value is missing, a `console.warning` is fired in dev environments, or a Sentry error is sent when on production.

Finally you can now use the new `ad` entity type when defining actions!

### Updating a Event/Entity Schema

...

### What About Batch Entities?

...

# How to Verify Snowplow Requests

## Snowplow Micro

If you want to keep all of your Snowplow events local to your computer while you develop, you can host your own Snowplow instance called Micro. It’s not required when hooking up new events, but it can be insightful.

_*TODO: Verify steps to set up Snowplow Micro and provide them here*_

## Snowplow Mini

When you run the `web-client` repo on your machine you’ll be sending events through our Snowplow Mini pipeline. All of Pocket’s dev environments are routed here, so it can be a bit unwieldy, but a good place to start is the [good events from the last 12 hours](https://com-getpocket-prod1.mini.snplow.net/kibana/app/kibana#/discover?_g=(refreshInterval:(pause:!t,value:0),time:(from:now-12h,mode:quick,to:now))&_a=(columns:!(app_id,event_name,page_urlhost),index:good,interval:auto,query:(language:lucene,query:'contexts_com_pocket_api_user_1:%20%20*89624%20*'),sort:!(collector_tstamp,desc))). If you need access you can check with the data-team.

## The Poplin Extension

The Poplin extension is a great way to verify outbound analytics requests. It’s available for Chrome and Firefox.

Make sure to disable Ad Blockers to verify in your local environment.

### Installing Poplin on Firefox

This extension is not officially supported on Firefox, so you’ll need to install the `.xpi` file manually.

1. First step, [download the latest xpi file](https://github.com/poplindata/chrome-snowplow-inspector/releases)
2. In Firefox, go to `about:addons`
3. Find the ⚙️ (gear) icon and click “Install add-on from file”
4. Should be self-explanatory from here on out

### Using Poplin

The extension is available via the developer panel in your browser. It will show you every event sent from the application.

If you’re interested, you can dig through the [source code](https://github.com/poplindata/chrome-snowplow-inspector).

### Recommendations

The data and analytics team has asked that all `ui` entities with an `indentifier` that contains the word `home`, `discover`, or `rec` means that this event is tied to a recommendation.
