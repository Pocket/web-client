AWSTemplateFormatVersion: 2010-09-09
Description: Web Client Feature Service - Shared architecurre for each feature deployment
Parameters:
  PublicSubnets:
    Type: "AWS::SSM::Parameter::Value<List<AWS::EC2::Subnet::Id>>"

  Vpc:
    Type: "AWS::SSM::Parameter::Value<AWS::EC2::VPC::Id>"

  DefaultSecurityGroup:
    Type: AWS::SSM::Parameter::Value<AWS::EC2::SecurityGroup::Id>
    Description: "Security group used for shard resources"

  HostedZoneId:
    Type: String
    Description: The Amazon Route 53 Hosted Zone Id

  DomainBase:
    Type: String
    Description: The base domain

  IamStack:
    Type: String
    Description: "Stack name used to create IAM roles"

  SSLCertificateArn:
    Type: String
    Description: The SSL/TLS certificate ARN for *.BASEDOMAIN
    MinLength: 0
    MaxLength: 2048
    AllowedPattern: (^$|^arn:aws:acm:.*)

Resources:
  Alb:
    Type: "AWS::ElasticLoadBalancingV2::LoadBalancer"
    Properties:
      Name: !Ref AWS::StackName
      Subnets: !Ref PublicSubnets
      SecurityGroups:
        - !Ref SecurityGroup

  EcsCluster:
    Type: "AWS::ECS::Cluster"
    Properties:
      ClusterName: !Ref AWS::StackName

  DnsRecordSet:
    Type: "AWS::Route53::RecordSet"
    Properties:
      Type: A
      HostedZoneId: !Ref HostedZoneId
      AliasTarget:
        DNSName: !GetAtt Alb.DNSName
        HostedZoneId: !GetAtt Alb.CanonicalHostedZoneID
      Name:
        Fn::Join: [".", ["*", !Ref DomainBase, ""]]
    DependsOn:
      - Alb

  Listener:
    Type: "AWS::ElasticLoadBalancingV2::Listener"
    Properties:
      DefaultActions:
        - Type: redirect
          RedirectConfig:
            Protocol: HTTPS
            Port: 443
            StatusCode: HTTP_301
      LoadBalancerArn: !Ref Alb
      Port: 80
      Protocol: HTTP

  HttpsListener:
    Type: "AWS::ElasticLoadBalancingV2::Listener"
    Properties:
      DefaultActions:
        - Type: fixed-response
          FixedResponseConfig:
            StatusCode: 404
            ContentType: text/html
            MessageBody: |
              <!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
              <html xmlns="http://www.w3.org/1999/xhtml">
                 <head>
                    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
                    <title>404</title>
                 </head>
                 <body>
                    Oops! No deployment at this location.
                 </body>
              </html>
      LoadBalancerArn: !Ref Alb
      Port: 443
      Protocol: HTTPS
      Certificates:
        - CertificateArn: !Ref SSLCertificateArn

  LogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub "/ecs/webclient/feature/"
      RetentionInDays: 90

  SecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupName: !Sub "${AWS::StackName}SecurityGroup"
      GroupDescription: Internal security group
      VpcId: !Ref Vpc
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
      SecurityGroupEgress:
        - IpProtocol: "-1"
          FromPort: "-1"
          ToPort: "-1"
          CidrIp: 0.0.0.0/0
      Tags:
        - Key: "Name"
          Value: !Sub "${AWS::StackName}SecurityGroup"

  # AWS can't automatically set the Listener Rule Priority so we use a custom lambda to do it...
  # https://stackoverflow.com/questions/50003378/automatically-set-listenerrule-priority-in-cloudformation-template
  AlbListenerPriorityFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.lambda_handler
      Role:
        Fn::ImportValue: !Sub "${IamStack}-AllocateAlbRulePriorityCustomResourceLambdaRole"
      Code:
        ZipFile: |
          import json
          import os
          import random
          import uuid

          import boto3
          from botocore.vendored import requests

          SUCCESS = "SUCCESS"
          FAILED = "FAILED"
          # Member must have value less than or equal to 50000
          ALB_RULE_PRIORITY_RANGE = 1, 50000


          def lambda_handler(event, context):
              try:
                  _lambda_handler(event, context)
              except Exception as e:
                  # Must raise, otherwise the Lambda will be marked as successful, and the exception
                  # will not be logged to CloudWatch logs.
                  # Always send a response otherwise custom resource creation/update/deletion will be stuck
                  send(
                      event,
                      context,
                      response_status=FAILED if event['RequestType'] != 'Delete' else SUCCESS,
                      # Do not fail on delete to avoid rollback failure
                      response_data=None,
                      physical_resource_id=uuid.uuid4(),
                      reason=e,
                  )
                  raise


          def _lambda_handler(event, context):
              print("Received event: " + json.dumps(event, indent=2))

              physical_resource_id = event.get('PhysicalResourceId', str(uuid.uuid4()))
              response_data = {}

              if event['RequestType'] == 'Create':
                  elbv2_client = boto3.client('elbv2')
                  result = elbv2_client.describe_rules(ListenerArn=os.environ['ListenerArn'])

                  in_use = list(filter(lambda s: s.isdecimal(), [r['Priority'] for r in result['Rules']]))

                  priority = None
                  while not priority or priority in in_use:
                      priority = str(random.randint(*ALB_RULE_PRIORITY_RANGE))

                  response_data = {
                      'Priority': priority
                  }

              send(event, context, SUCCESS, response_data, physical_resource_id)


          def send(event, context, response_status, response_data, physical_resource_id, reason=None):
              response_url = event['ResponseURL']

              response_body = {
                  'Status': response_status,
                  'Reason': str(reason) if reason else 'See the details in CloudWatch Log Stream: ' + context.log_stream_name,
                  'PhysicalResourceId': physical_resource_id,
                  'StackId': event['StackId'],
                  'RequestId': event['RequestId'],
                  'LogicalResourceId': event['LogicalResourceId'],
                  'Data': response_data,
              }

              json_response_body = json.dumps(response_body)

              headers = {
                  'content-type': '',
                  'content-length': str(len(json_response_body))
              }

              try:
                  requests.put(
                      response_url,
                      data=json_response_body,
                      headers=headers
                  )
              except Exception as e:
                  print("send(..) failed executing requests.put(..): " + str(e))
      Runtime: python3.6
      Timeout: "30"
      Environment:
        Variables:
          ListenerArn: !Ref HttpsListener
  AssetBucket:
    Type: AWS::S3::Bucket
    DeletionPolicy: Delete
    Properties:
      BucketName: !Sub "${DomainBase}-assets"
      AccessControl: PublicRead
      WebsiteConfiguration:
        IndexDocument: index.html
        ErrorDocument: 404.html
      CorsConfiguration:
        CorsRules:
          - AllowedHeaders:
              - "*"
            AllowedMethods:
              - GET
            AllowedOrigins:
              - "*"
            MaxAge: "3000"
      LifecycleConfiguration:
        Rules:
          - Id: DeleteRule
            Status: Enabled
            ExpirationInDays: "180"
  AssetBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Sub "${DomainBase}-assets"
      PolicyDocument:
        Statement:
          - Sid: PublicReadForGetBucketObjects
            Effect: Allow
            Principal: "*"
            Action: s3:GetObject
            Resource:
              !Join ["", ["arn:aws:s3:::", !Sub "${DomainBase}-assets", /*]]
  AssetCloudfront:
    Type: AWS::CloudFront::Distribution
    DependsOn:
      - AssetBucket
    Properties:
      DistributionConfig:
        Comment: Cloudfront Distribution pointing to S3 bucket
        Origins:
          - DomainName:
              !Select [2, !Split ["/", !GetAtt AssetBucket.WebsiteURL]]
            Id: S3Origin
            CustomOriginConfig:
              HTTPPort: "80"
              HTTPSPort: "443"
              OriginProtocolPolicy: http-only
        Enabled: true
        HttpVersion: "http2"
        DefaultCacheBehavior:
          AllowedMethods:
            - GET
            - HEAD
          Compress: true
          TargetOriginId: S3Origin
          ForwardedValues:
            QueryString: false
            Cookies:
              Forward: none
          ViewerProtocolPolicy: redirect-to-https
        PriceClass: PriceClass_200
        ViewerCertificate:
          CloudFrontDefaultCertificate: true
Outputs:
  EcsCluster:
    Value: !GetAtt EcsCluster.Arn
    Export:
      Name: !Sub "${AWS::StackName}-EcsClusterArn"
  SecurityGroup:
    Value: !Ref SecurityGroup
    Export:
      Name: !Sub "${AWS::StackName}-SecurityGroupArn"
  ListenerARN:
    Value: !Ref HttpsListener
    Export:
      Name: !Sub "${AWS::StackName}-ListenerARN"
  AlbListenerPriorityFunction:
    Value: !GetAtt AlbListenerPriorityFunction.Arn
    Export:
      Name: !Sub "${AWS::StackName}-AlbListenerPriorityFunction"
