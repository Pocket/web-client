version: 2.1

# Orbs: Pre-configured bundled functionality
orbs:
  aws-cli: circleci/aws-cli@1.2.1
  aws-ecr: circleci/aws-ecr@6.10.0
  assume-role: airswap/assume-role@0.2.0
  # cypress: cypress-io/cypress@1
  slack: circleci/slack@3.4.0
  aws-ecs: circleci/aws-ecs@2.0.0
  pocket: pocket/circleci-orbs@1.0.0
  queue: eddiewebb/queue@1.5.0

# Commands: Setting up some tasks to avoid a lot of boilerplate
commands:
  setup:
    description: "Preparing the environment"
    steps:
      # Define the working directory for this job
      - attach_workspace:
          at: /tmp/workspace
      # Checkout source code into the working_directory.
      - checkout
      # Add user to npmrc
      - run:
          name: Authenticate with GitHub package registry
          command: echo "//npm.pkg.github.com/:_authToken=${GITHUB_TOKEN}" > ~/.npmrc
      # Restores a previously saved cache based on a key.
      - restore_cache:
          keys:
            # when lock file changes, use increasingly general patterns to restore cache
            # If this gets our of sync, you can increment the version (vX).  Just be
            # sure to match that version when saving the cache as well.
            - node-v6-{{ checksum "package-lock.json" }}
            - node-v6-
      # Install javascript dependencies
      - run:
          name: Install dependencies
          command: npm install
      # Save the cache to avoid extraneous downloads
      - save_cache:
          key: node-v6-{{ checksum "package-lock.json" }}
          paths:
            - ./node_modules
            - ./.next/cache

# Jobs: Setting up tasks for CI to execute
jobs:

  # ——————————————————————————————————————————————————————————————
  # Unit Test: Make sure code is free from testable errors
  # ——————————————————————————————————————————————————————————————
  unit_tests:
    # CPU and RAM resources for the job.
    resource_class: small
    # Define the container we will run the task in (standard node)
    docker:
      - image: circleci/node:14
    steps:
      # Setup Environment
      - setup
      # Run tests
      - run:
          name: Run unit tests
          command: npm test

  # ——————————————————————————————————————————————————————————————
  # Release: This will tag the branch and generate a changelog
  # ——————————————————————————————————————————————————————————————  
  release:
    # CPU and RAM resources for the job.
    resource_class: small
    # Define the container we will run the task in (standard node)
    docker:
      - image: circleci/node:lts
    steps:
      - setup
      - add_ssh_keys:
          fingerprints:
            - '95:3f:a9:02:0d:06:71:f9:5d:90:1e:a0:e5:e3:c3:25'
      # Semantic Release
      - run: npx semantic-release
      - run:
          name: Check for new release
          command: |
            if [ -f ".version" ]; then
              echo "We have a semantic release"
            else
              echo 'No semantically releasable changes.'
              echo `git describe --abbrev=0 --tags` > .version
            fi  
            cp .version /tmp/workspace/.version
      - persist_to_workspace:
          root: /tmp/workspace
          paths:
            - .version
  
  # ——————————————————————————————————————————————————————————————
  # Integration Test: Make sure our happy paths have not regressed
  # ——————————————————————————————————————————————————————————————
  # integration_tests:
  #   # CPU and RAM resources for the job.
  #   resource_class: small
  #   # Define the container we will run the task in (standard node)
  #   docker:
  #     - image: cypress/base:14.0.0
  #   steps:
  #     # Setup Environment
  #     - setup
  #     # Run tests
  #     - run:
  #         name: Run integration tests
  #         command: 'CYPRESS_BASE_URL=https://$(sed s/[/]//g \<<<$CIRCLE_BRANCH).web-client.getpocket.dev npm run cypress:ci'
  #     - store_artifacts:
  #         path: ./cypress

  # ——————————————————————————————————————————————————————————————
  # Build Deployment: This builds the nextjs deployment
  # This is used for features and production
  # @prefix {String}: Provide asset prefix to use CDN for css/js files
  # NOTE: NextJS does not automatically prefix media assets.
  # ——————————————————————————————————————————————————————————————
  build_app:
    parameters:
      prefix:
        description: The assets prefix
        type: string
        default: ""
      showdev:
        description: Including dev tools
        type: string
        default: ""
    # CPU and RAM resources for the job.
    resource_class: medium
    # Define the container we will run the task in (standard node)
    docker:
      - image: circleci/node:14
    steps:
      # Setup Environment
      - setup
      - add_ssh_keys:
          fingerprints:
            - "95:3f:a9:02:0d:06:71:f9:5d:90:1e:a0:e5:e3:c3:25"
      - run:
          name: Setup common environment variables
          command: |
            echo 'export RELEASE_VERSION="$(cat /tmp/workspace/.version)"' >> $BASH_ENV
      - run:
          name: Set version
          command: |
            mkdir -p config
            echo "module.exports = '$CIRCLE_SHA1';" > ./config/version.js
      - run:
          name: Build
          command: RELEASE_VERSION=${RELEASE_VERSION} ASSET_PREFIX=<<parameters.prefix>> SHOW_DEV=<<parameters.showdev>> NODE_ENV=production npm run build
      # Copy built files to app_prod folder
      - run:
          name: Setup workspace
          command: |
            mkdir -p /tmp/workspace/app_prod
            cp -r . /tmp/workspace/app_prod
      # Persist built files to workspace
      - persist_to_workspace:
          root: /tmp/workspace
          paths:
            - app_prod

   # ——————————————————————————————————————————————————————————————
  
  # Tag ECR(Elastic Container Repository)
  # This tags docker image as latest for use by devOps
  # ——————————————————————————————————————————————————————————————
  tag:
    docker:
      - image: pocket/ops-cli:latest
        environment:
          MAIN_IMAGE_NAME: web-client
    steps:
      - setup_remote_docker
      - run:
          name: Setup common environment variables
          command: |
            echo 'export AWS_ECR_ACCOUNT_URL="${ACCOUNT_ID_PROD}.dkr.ecr.us-east-1.amazonaws.com"' >> $BASH_ENV
            echo 'export AWS_ACCESS_KEY_ID="${OLD_AWS_ACCESS_KEY_ID}"' >> $BASH_ENV
            echo 'export AWS_SECRET_ACCESS_KEY="${OLD_AWS_SECRET_ACCESS_KEY}"' >> $BASH_ENV
      - assume-role/assume-role:
          account-id: $ACCOUNT_ID_PROD
      - aws-ecr/ecr-login
      - run:
          name: Tag As latest
          command: |
            docker pull ${AWS_ECR_ACCOUNT_URL}/${MAIN_IMAGE_NAME}:${CIRCLE_SHA1}
            docker tag ${AWS_ECR_ACCOUNT_URL}/${MAIN_IMAGE_NAME}:${CIRCLE_SHA1} ${AWS_ECR_ACCOUNT_URL}/${MAIN_IMAGE_NAME}:latest
      - aws-ecr/push-image:
          repo: $MAIN_IMAGE_NAME
          tag: latest

  # ——————————————————————————————————————————————————————————————
  # Build Production Container
  # Copy everything from workspace into a Docker image for ssr rendering
  # ——————————————————————————————————————————————————————————————
  build_production_container:
    # Define the container we will run the task in (standard node)
    docker:
      - image: pocket/ops-cli:v0.0.5
    # Define the environment
    environment:
      MAIN_IMAGE_NAME: web-client
    steps:
      - attach_workspace:
          at: /tmp/workspace
      - run:
          name: Setup common environment variables
          command: |
            echo 'export AWS_ECR_ACCOUNT_PROD_URL="${ACCOUNT_ID_PROD}.dkr.ecr.us-east-1.amazonaws.com"' >> $BASH_ENV
            echo 'export AWS_ECR_ACCOUNT_DEV_URL="${ACCOUNT_ID_DEV}.dkr.ecr.us-east-1.amazonaws.com"' >> $BASH_ENV
            echo 'export AWS_ECR_ACCOUNT_URL="${AWS_ECR_ACCOUNT_PROD_URL}"' >> $BASH_ENV
            echo 'export AWS_ACCESS_KEY_ID="${OLD_AWS_ACCESS_KEY_ID}"' >> $BASH_ENV
            echo 'export AWS_SECRET_ACCESS_KEY="${OLD_AWS_SECRET_ACCESS_KEY}"' >> $BASH_ENV
            echo 'export RELEASE_VERSION="$(cat /tmp/workspace/.version)"' >> $BASH_ENV
      - run:
          name: "What version is being built?"
          command: echo ${RELEASE_VERSION}
      - run:
          name: Copy App
          command: |
            cp -r /tmp/workspace/app_prod/. .
      - assume-role/assume-role:
          account-id: $ACCOUNT_ID_PROD
      - aws-ecr/build-and-push-image:
          checkout: false
          repo: $MAIN_IMAGE_NAME
          setup-remote-docker: true
          tag: $CIRCLE_SHA1
          path: /tmp/workspace/app_prod
          dockerfile: /tmp/workspace/app_prod/Dockerfile
          extra-build-args: --build-arg RELEASE_VERSION=${RELEASE_VERSION}
      - assume-role/assume-role:
          account-id: $ACCOUNT_ID_DEV
      - run:
          name: Retag And Setup
          command: |
            echo 'export AWS_ECR_ACCOUNT_URL="${AWS_ECR_ACCOUNT_DEV_URL}"' >> $BASH_ENV
            docker tag ${AWS_ECR_ACCOUNT_PROD_URL}/${MAIN_IMAGE_NAME}:$CIRCLE_SHA1 ${AWS_ECR_ACCOUNT_DEV_URL}/${MAIN_IMAGE_NAME}:$CIRCLE_SHA1
      - aws-ecr/ecr-login
      - aws-ecr/push-image:
          repo: $MAIN_IMAGE_NAME
          tag: $CIRCLE_SHA1

  # ——————————————————————————————————————————————————————————————
  # Push Production Assets:
  # Push built deployment to the s3 bucket for client side caching
  # ——————————————————————————————————————————————————————————————
  push_production_assets:
    docker:
      - image: circleci/python # for aws cli without fluff
    steps:
      - run:
          name: Setup environment variables
          command: |
            echo 'export AWS_ACCESS_KEY_ID="${OLD_AWS_ACCESS_KEY_ID}"' >> $BASH_ENV
            echo 'export AWS_SECRET_ACCESS_KEY="${OLD_AWS_SECRET_ACCESS_KEY}"' >> $BASH_ENV
      - aws-cli/install
      - assume-role/assume-role:
          account-id: $ACCOUNT_ID_PROD
      - attach_workspace:
          at: .
      - run:
          name: Push
          command: |
            aws s3 cp \
            --recursive \
            --acl public-read \
            --metadata-directive REPLACE \
            --cache-control max-age=31536000 \
            --include "*" \
            --exclude "BUILD_ID" \
            app_prod/.next s3://readitlater-deploy/web-client/_next

  # ——————————————————————————————————————————————————————————————
  # Deploy:
  # This runs our terraform jobs to adjust aws settings and points
  # production to the new git sha
  # ——————————————————————————————————————————————————————————————
  deploy:
    parameters:
      deploy:
        description: Should deploy
        type: boolean
        default: false
    docker:
      - image: pocket/ops-cli:v0.0.5
        environment:
          TF_WORKSPACE: production
    steps:
      - checkout
      - run:
          name: Install Terraform
          command: |
            export TERRAFORM=0.14.4
            #$(curl -s https://checkpoint-api.hashicorp.com/v1/check/terraform | jq -r -M '.current_version')
            wget https://releases.hashicorp.com/terraform/${TERRAFORM}/terraform_${TERRAFORM}_linux_amd64.zip
            sudo unzip ./terraform_${TERRAFORM}_linux_amd64.zip -d /usr/local/bin/
      - run:
          name: Setup environment variables
          command: |
            echo 'export AWS_ACCESS_KEY_ID="${OLD_AWS_ACCESS_KEY_ID}"' >> $BASH_ENV
            echo 'export AWS_SECRET_ACCESS_KEY="${OLD_AWS_SECRET_ACCESS_KEY}"' >> $BASH_ENV
      - assume-role/assume-role:
          account-id: $ACCOUNT_ID_PROD
      - run:
          name: Setup Stack
          command: |
            cd .aws/production
            variables=$(cat \<<-END
            credentials "app.terraform.io" {
            token = "$TERRAFORM_TOKEN"
            }
            END
            )
            echo $variables > ~/.terraformrc
            terraform init -input=false
      - when:
          condition: << parameters.deploy >>
          steps:
            - run:
                name: Deploy Push
                command: |
                  aws ssm put-parameter --name "/Web-Client/CircleCI/Production/BUILD_BRANCH" --type "SecureString" --value "${CIRCLE_BRANCH}" --overwrite
                  aws ssm put-parameter --name "/Web-Client/CircleCI/Production/SERVICE_VERSION" --type "SecureString" --value "${CIRCLE_BUILD_NUM}" --overwrite
                  aws ssm put-parameter --name "/Web-Client/CircleCI/Production/SERVICE_HASH" --type "SecureString" --value "${CIRCLE_SHA1}" --overwrite
                  cd .aws/production
                  terraform apply \
                    -auto-approve \
                    -lock-timeout=600s \
                    -var-file="_globals.tfvars"
            - assume-role/assume-role:
                account-id: $ACCOUNT_ID_DEV
            - run:
                name: Push Dev Variables
                command: |
                  aws ssm put-parameter --name "/Web-Client/CircleCI/Development/BUILD_BRANCH" --type "SecureString" --value "${CIRCLE_BRANCH}" --overwrite
                  aws ssm put-parameter --name "/Web-Client/CircleCI/Development/SERVICE_VERSION" --type "SecureString" --value "${CIRCLE_BUILD_NUM}" --overwrite
                  aws ssm put-parameter --name "/Web-Client/CircleCI/Development/SERVICE_HASH" --type "SecureString" --value "${CIRCLE_SHA1}" --overwrite
      - unless:
          condition: << parameters.deploy >>
          steps:
            - run:
                name: Output Push Plan
                command: |
                  cd .aws/production
                  terraform plan \
                    -lock=false \
                    -refresh=false \
                    -out=prod.plan \
                    -var-file="_globals.tfvars"
            - store_artifacts:
                path: .aws/production/prod.plan

  # ——————————————————————————————————————————————————————————————
  # Deployment Notification:
  # This adds notification to slack on a successful live deploy
  # ——————————————————————————————————————————————————————————————
  deploy_end_notification:
    resource_class: small
    docker:
      - image: pocket/ops-cli:v0.0.4
    steps:
      - attach_workspace:
          at: /tmp/workspace
      - run:
          name: Slack Deploy End Notification
          command: |
            curl -X POST -H 'Content-type: application/json' \
            --data "{
              \"username\": \"buster\",
              \"icon_emoji\": \":web-client-done:\",
              \"channel\": \"log-web-client-deploys\",
              \"text\": \"Completed deploy of <https://github.com/Pocket/web-client/commit/$CIRCLE_SHA1> by <https://github.com/$CIRCLE_USERNAME|$CIRCLE_USERNAME>\",
              \"attachments\": [
                {
                    \"color\": \"#36a64f\",
                    \"fallback\": \"Workflow\",
                    \"title\": \"Workflow\",
                    \"title_link\": \"https://circleci.com/workflow-run/$CIRCLE_WORKFLOW_ID\"
                }
            ]}" \
             $SLACK_WEBHOOK
      - run:
          name: Sentry Release Notification
          command: |
            curl https://sentry.io/api/0/organizations/pocket/releases/ \
              -X POST \
              -H "Authorization: Bearer $SENTRY_BEARER" \
              -H 'Content-Type: application/json' \
              -d "
                {
                  \"version\": \"$CIRCLE_SHA1\",
                  \"refs\": [{
                      \"repository\":\"Pocket/web-client\",
                      \"commit\":\"$CIRCLE_SHA1\"
                  }],
                  \"projects\":[\"web-client\"]
                }
              "
            curl https://sentry.io/api/0/organizations/pocket/releases/$CIRCLE_SHA1/deploys/ \
               -X POST \
               -H "Authorization: Bearer $SENTRY_BEARER" \
               -H 'Content-Type: application/json' \
               -d "
                 {
                   \"environment\": \"Production\"
                 }
               "


  # ——————————————————————————————————————————————————————————————
  # !! NEW ALB
  # Build the app along with the docker image to use for this version
  # Will push the docker image to ECR (Elastic Container Repository)
  # ECS will access this image to build a container to run the app
  # ——————————————————————————————————————————————————————————————
  docker_build:
    parameters:
      tag:
        description: 'The docker tag name'
        type: string
      environment:
        description: 'The environment name'
        type: string
      ecr_url:
        description: 'The ecr url'
        type: string
      repo_name:
        description: 'The ecr repo name'
        type: string
      push:
        # This allows us to test that the image can be built without
        # without pushing broken code to production 
        description: 'Whether or not to push the code'
        type: boolean
        default: false
    docker:
      - image: pocket/ops-cli:v0.0.5
    steps:
      - attach_workspace:
          at: /tmp/workspace
      - run:
          name: Setup common environment variables
          command: |
            echo 'export AWS_ECR_ACCOUNT_URL="<< parameters.ecr_url >>"' >> $BASH_ENV
            echo 'export AWS_REGION=${<< parameters.environment >>_AWS_DEFAULT_REGION}' >> $BASH_ENV
            echo 'export RELEASE_VERSION="$(cat /tmp/workspace/.version)"' >> $BASH_ENV
      - run: 
          name: "What version is being built?"
          command: echo ${RELEASE_VERSION}
      - when:
          condition: <<parameters.push>>
          steps:
            - aws-ecr/build-and-push-image:
                checkout: false
                repo: << parameters.repo_name >>
                setup-remote-docker: true
                path: /tmp/workspace/app_prod
                aws-access-key-id: << parameters.environment >>_AWS_ACCESS_KEY
                aws-secret-access-key: << parameters.environment >>_AWS_SECRET_ACCESS_KEY
                tag: << parameters.tag >>
                extra-build-args: --build-arg RELEASE_VERSION=${RELEASE_VERSION}
      - unless:
          condition: <<parameters.push>>
          steps:
            - setup_remote_docker
            - aws-ecr/build-image:
                repo: << parameters.repo_name >>
                tag: << parameters.tag >>
                path: /tmp/workspace/app_prod
                extra-build-args: --build-arg RELEASE_VERSION=${RELEASE_VERSION}

  # ——————————————————————————————————————————————————————————————
  # !! NEW ALB
  # That's it. Crazy.
  # ——————————————————————————————————————————————————————————————


# Workflow switches
not_main: &not_main
  filters:
    branches:
      ignore:
        - main
        
only_main: &only_main
  filters:
    branches:
      only:
        - main

not_dev: &not_dev
  filters:
    branches:
      ignore:
        - dev

only_dev_main: &only_dev_main
  filters:
    branches:
      only:
        - dev
        - main

not_dev_main: &not_dev_main
  filters:
    branches:
      ignore:
        - dev
        - main

only_dev: &only_dev
  filters:
    branches:
      only:
        - dev

# Workflows: Executing jobs we have defined based on specific branch changes
workflows:
  version: 2
  all:
    jobs:
      # unit test all the files
      - unit_tests:
          <<: *not_main
      # Generate a changelog tag when main is updated
      - release:
          <<: *only_main
      # conditionally building deployment with or without asset prefix
      - build_app:
          <<: *only_main
          prefix: "https://assets.getpocket.com/web-client"
          showdev: ""
          name: build_app_production
          requires:
            - release
      # we are building on branch to make sure there are no build errors
      - build_app:
          <<: *not_main
          prefix: ""
          showdev: "included"
          name: build_app_dev
      # Cypress Integration Tests
      # - integration_tests:
      #     <<: *only_main
      #     requires:
      #       - push_feature_assets
      #       - deploy_feature

      # conditional push production build and assets (css/js) for main branch
      - push_production_assets:
          <<: *only_main
          requires:
            - build_app_production
      - build_production_container:
          requires:
            - build_app_production
      - tag:
          <<: *only_main
          requires:
            - build_production_container
      # Check to make sure our terraform is correct on branches
      - deploy:
          <<: *not_main
          deploy: false
          name: check_production
      - deploy:
          <<: *only_main
          deploy: true
          name: deploy_production
          requires:
            - build_production_container
            - push_production_assets
      - deploy_end_notification:
          <<: *only_main
          requires:
            - deploy_production

       # Try building the ECS docker image on each branch
       # !! This pushes to a dev account
       # !! Get rid of this To spite Kelvin
       # !! Change this to not_main instead of getting rid of it
       # !! secretly get rid of it when kelvin isn't watching me
      - docker_build:
          <<: *not_dev_main
          context: pocket
          name: build_docker
          environment: 'Dev'
          tag: latest,$CIRCLE_SHA1
          # dev-app is based on how its created in shared infrastructure
          # https://github.com/Pocket/shared-infrastructure
          repo_name: webclient-dev-app 
          ecr_url: 410318598490.dkr.ecr.us-east-1.amazonaws.com
          push: false
          requires:
            - build_app_dev # Make sure build is not funky and change this to that

      # !! Get rid of this too
      # Build & Deploy the Dev Docker Image
      - docker_build:
          <<: *only_dev
          context: pocket
          name: build_docker_dev
          environment: 'Dev'
          tag: latest,$CIRCLE_SHA1
          repo_name: webclient-dev-app
          ecr_url: 410318598490.dkr.ecr.us-east-1.amazonaws.com
          push: true
          requires:
            - build_app_dev

      - queue/block_workflow:
          <<: *only_dev_main
          context: pocket
          name: wait_for_deploy_queue
          time: '30'

      # !! This pushes to a dev account
      - aws-ecs/deploy-service-update:
          <<: *only_dev
          context: pocket
          name: deploy_ecs_dev
          family: 'WebClient-Dev'
          cluster-name: 'WebClient-Dev'
          deployment-controller: 'CODE_DEPLOY'
          codedeploy-application-name: 'WebClient-Dev-ECS'
          codedeploy-deployment-group-name: 'WebClient-Dev-ECS'
          codedeploy-load-balanced-container-name: app
          codedeploy-load-balanced-container-port: 4003
          container-image-name-updates: 'container=app,image-and-tag=410318598490.dkr.ecr.us-east-1.amazonaws.com/webclient-dev-app:$CIRCLE_SHA1'
          aws-access-key-id: Dev_AWS_ACCESS_KEY
          aws-secret-access-key: Dev_AWS_SECRET_ACCESS_KEY
          aws-region: Dev_AWS_DEFAULT_REGION
          verify-revision-is-deployed: true
          verification-timeout: '30'
          requires:
            - build_docker_dev
            - wait_for_deploy_queue

      # Build & Deploy the Prod Docker Image
      - docker_build:
          <<: *only_main
          context: pocket
          name: build_docker_prod
          environment: 'Prod'
          tag: latest,$CIRCLE_SHA1
          repo_name: webclient-prod-app
          ecr_url: 996905175585.dkr.ecr.us-east-1.amazonaws.com
          push: true
          requires:
            - build_app_production

      - aws-ecs/deploy-service-update:
          <<: *only_main
          name: deploy_ecs_prod
          context: pocket
          family: 'WebClient-Prod'
          cluster-name: 'WebClient-Prod'
          deployment-controller: 'CODE_DEPLOY'
          codedeploy-application-name: 'WebClient-Prod-ECS'
          codedeploy-deployment-group-name: 'WebClient-Prod-ECS'
          codedeploy-load-balanced-container-name: app
          codedeploy-load-balanced-container-port: 4003
          container-image-name-updates: 'container=app,image-and-tag=996905175585.dkr.ecr.us-east-1.amazonaws.com/webclient-prod-app:$CIRCLE_SHA1'
          aws-access-key-id: Prod_AWS_ACCESS_KEY
          aws-secret-access-key: Prod_AWS_SECRET_ACCESS_KEY
          aws-region: Prod_AWS_DEFAULT_REGION
          verify-revision-is-deployed: true
          verification-timeout: '30'
          requires:
            - build_docker_prod
            - wait_for_deploy_queue

      - pocket/setup_deploy_params:
          <<: *only_main
          name: setup-deploy-params-prod
          aws_access_key_id: Prod_AWS_ACCESS_KEY
          aws_secret_access_key: Prod_AWS_SECRET_ACCESS_KEY
          context: pocket
          env: Prod
          service_name: WebClient

      # !! This pushes to a dev account
      - pocket/setup_deploy_params:
          <<: *only_dev
          name: setup-deploy-params-dev
          aws_access_key_id: Dev_AWS_ACCESS_KEY
          aws_secret_access_key: Dev_AWS_SECRET_ACCESS_KEY
          context: pocket
          env: Dev
          service_name: WebClient

      # Notify sentry of main deployment
      - pocket/sentry_release_notification:
          <<: *only_main
          name: sentry-release-notification-prod
          context: pocket
          repository_name: Pocket/web-client
          sentry_project_name: web-client
          sentry_env: production
          sentry_org: pocket
          workspace-path: /tmp/workspace
          requires:
            - deploy_ecs_prod

      # !! This pushes to a dev account
      # Notify sentry of dev deployment
      - pocket/sentry_release_notification:
          <<: *only_dev
          name: sentry-release-notification-dev
          context: pocket
          repository_name: Pocket/web-client
          sentry_project_name: web-client
          sentry_env: development
          sentry_org: pocket
          workspace-path: /tmp/workspace
          requires:
            - deploy_ecs_dev
